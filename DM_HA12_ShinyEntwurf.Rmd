---
title: "Untitled"
runtime: shiny
output: html_document
---

This R Markdown document is made interactive using Shiny. Unlike the more traditional workflow of creating static reports, you can now create documents that allow your readers to change the assumptions underlying your analysis and see the results immediately. 

To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).

## Inputs and Outputs

You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.

```{r, echo=FALSE}
setwd("/home/florian/Schreibtisch/UNI/Master/1_Semester/Datenmanagement/Basisdaten/Fogo")
library(sp)
library(rgdal)
library(raster)
library(gridExtra)
library("lattice", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.2")
library("latticeExtra", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.2")

raster <- raster("LC82100502014328LGN00_B3.tif")
vector <- readOGR("data_2014_subset1.shp", layer = "data_2014_subset1")
vector_utm <- spTransform(vector, CRS(projection(raster)))
min <- max(mean(getValues(raster)) - sd(getValues(raster)), 0)
max <- mean(getValues(raster)) + sd(getValues(raster))
yat = seq(extent(raster)@ymin, 
          extent(raster)@ymax, length.out = 5)
xat = seq(extent(raster)@xmin, 
          extent(raster)@xmax, length.out = 5)
breaks <- seq(min, max, length.out = 256)
vector_classes <- cut(vector_utm@data$NAT, c(0,1,2,3,4,5,6,7,8,9))
vector_colors <- colorRampPalette(brewer.pal(9,"Greens"))(9)
#vorher choose_gridlines <- seq(1:25)
# vector_attributes <- vector(names)


inputPanel(
#   selectInput("Colors", label = "Color",
#               choices = color_maps, selected = "Red")
#######NOTE######
# die Variable color_maps hat er vorher evtl nicht erkannt, weil diese nicht Teil des Rasters/Shapes ist, ggf. muss man diese erst demjenigen hinzuf체gen, sodass er diese im Shiny Format gebrauchen kann


  # selectInput("GRIDLI", label = "Number of Gridlines",
              # choices = (scales = list(x = list(at = xat),
                                      # y = list(at = yat)), selected = 5))
  # voher choices = choose_gridlines
  selectInput(inputId = "attributes", label = "attribut",
              choices = names(vector), selected = "NAT")
  
)
## Theoretisch, laut Nauss m체sste in RenderPlot statt "breaks" "z" bzw. "zcol" stehen. aber jetzt stellt er es zumindest dar. WObei das z/zcol/breaks = eigentlich f체r die Shape Datei wichtig w채re. Die es irgendwie zu implementieren gilt
## Problem, er hat quasi keinen Zugriff auf die Shape Datei, die gilt es zu implementieren
renderPlot({
  plot1 <- spplot(raster, col.regions = gray.colors(256), at = breaks,
              key = list(space = 'left', text = list(levels(vector_classes)), 
                         points = list(pch = 21, cex = 2, fill = vector_colors)),
              colorkey=list(space="right"),
              panel = function(...){
                panel.levelplot(...)
                panel.abline(h = yat, v = xat, col = "grey0", lwd = 0.8, lty = 3) 
              },
              scales = list(x = list(at = xat),
                            y = list(at = yat)))
   
  plot2 <- spplot(vector, zcol = input$attributes)
  
## Versuch die zu mergen, Funktion war irgendwo bei Naus. Aber wie es der NAme sagt, geht es hier wohl lediglich darum sie anzuordnen und nicht zu verschelzen
  grid.arrange(plot1, plot2, ncol = 1)
  
  # finalplot <- spplot + as.layer(spplot2)
})
```



